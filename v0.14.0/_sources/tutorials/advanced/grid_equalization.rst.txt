
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/advanced/grid_equalization.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_advanced_grid_equalization.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_advanced_grid_equalization.py:


Performing grid histogram equalization
======================================

The :meth:`pygmt.grdhisteq.equalize_grid` method creates a grid using
statistics based on a cumulative distribution function.

.. GENERATED FROM PYTHON SOURCE LINES 10-12

.. code-block:: Python

    import pygmt








.. GENERATED FROM PYTHON SOURCE LINES 13-19

Load sample data
----------------

Load the sample Earth relief data for a region around Yosemite Valley
and use :func:`pygmt.grd2xyz` to create a :class:`pandas.Series` with the
z-values.

.. GENERATED FROM PYTHON SOURCE LINES 19-26

.. code-block:: Python


    grid = pygmt.datasets.load_earth_relief(
        resolution="03s", region=[-119.825, -119.4, 37.6, 37.825]
    )
    grid_dist = pygmt.grd2xyz(grid=grid, output_type="pandas")["z"]









.. GENERATED FROM PYTHON SOURCE LINES 27-32

Plot the original digital elevation model and data distribution
---------------------------------------------------------------

For comparison, we will create a map of the original digital elevation
model and a histogram showing the distribution of elevation data values.

.. GENERATED FROM PYTHON SOURCE LINES 32-63

.. code-block:: Python


    # Create an instance of the Figure class
    fig = pygmt.Figure()
    # Define figure configuration
    pygmt.config(FORMAT_GEO_MAP="ddd.x", MAP_FRAME_TYPE="plain")
    # Define the colormap for the figure
    pygmt.makecpt(series=[500, 3540], cmap="turku")
    # Setup subplots with two panels
    with fig.subplot(
        nrows=1, ncols=2, figsize=("13.5c", "4c"), title="Digital Elevation Model"
    ):
        # Plot the original digital elevation model in the first panel
        with fig.set_panel(panel=0):
            fig.grdimage(grid=grid, projection="M?", frame="WSne", cmap=True)
        # Plot a histogram showing the z-value distribution in the original digital
        # elevation model
        with fig.set_panel(panel=1):
            fig.histogram(
                data=grid_dist,
                projection="X?",
                region=[500, 3600, 0, 20],
                series=[500, 3600, 100],
                frame=["wnSE", "xaf+lElevation (m)", "yaf+lPercent frequency"],
                cmap=True,
                histtype=1,
                pen="1p,black",
            )
            fig.colorbar(position="JMR+o1.5c/0c+w3c/0.3c", frame=True)
    fig.show()





.. image-sg:: /tutorials/advanced/images/sphx_glr_grid_equalization_001.png
   :alt: grid equalization
   :srcset: /tutorials/advanced/images/sphx_glr_grid_equalization_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 64-73

Equalize grid based on a linear distribution
--------------------------------------------

The :meth:`pygmt.grdhisteq.equalize_grid` method creates a new grid with the
z-values representing the position of the original z-values in a given
cumulative distribution. By default, it computes the position in a linear
distribution. Here, we equalize the grid into nine divisions based on a
linear distribution and produce a :class:`pandas.Series` with the z-values
for the new grid.

.. GENERATED FROM PYTHON SOURCE LINES 73-79

.. code-block:: Python


    divisions = 9
    linear = pygmt.grdhisteq.equalize_grid(grid=grid, divisions=divisions)
    linear_dist = pygmt.grd2xyz(grid=linear, output_type="pandas")["z"]









.. GENERATED FROM PYTHON SOURCE LINES 80-90

Calculate the bins used for data transformation
-----------------------------------------------

The :meth:`pygmt.grdhisteq.compute_bins` method reports statistics about the
grid equalization. Here, we report the bins that would linearly divide the
original data into 9 divisions with equal area. In our new grid produced by
:meth:`pygmt.grdhisteq.equalize_grid`, all the grid cells with values between
``start`` and ``stop`` of ``bin_id=0`` are assigned the value 0, all grid
cells with values between ``start`` and ``stop`` of ``bin_id=1`` are assigned
the value 1, and so on.

.. GENERATED FROM PYTHON SOURCE LINES 90-94

.. code-block:: Python


    pygmt.grdhisteq.compute_bins(grid=grid, divisions=divisions)







.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>start</th>
          <th>stop</th>
        </tr>
        <tr>
          <th>bin_id</th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>508.0</td>
          <td>1352.0</td>
        </tr>
        <tr>
          <th>1</th>
          <td>1352.0</td>
          <td>1719.0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>1719.0</td>
          <td>1972.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>1972.0</td>
          <td>2156.0</td>
        </tr>
        <tr>
          <th>4</th>
          <td>2156.0</td>
          <td>2270.0</td>
        </tr>
        <tr>
          <th>5</th>
          <td>2270.0</td>
          <td>2391.0</td>
        </tr>
        <tr>
          <th>6</th>
          <td>2391.0</td>
          <td>2520.0</td>
        </tr>
        <tr>
          <th>7</th>
          <td>2520.0</td>
          <td>2739.0</td>
        </tr>
        <tr>
          <th>8</th>
          <td>2739.0</td>
          <td>3533.0</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 95-101

Plot the equally distributed data
---------------------------------

Here we create a map showing the grid that has been transformed to
have a linear distribution with nine divisions and a histogram of the data
values.

.. GENERATED FROM PYTHON SOURCE LINES 101-132

.. code-block:: Python


    # Create an instance of the Figure class
    fig = pygmt.Figure()
    # Define figure configuration
    pygmt.config(FORMAT_GEO_MAP="ddd.x", MAP_FRAME_TYPE="plain")
    # Define the colormap for the figure
    pygmt.makecpt(series=[0, divisions, 1], cmap="lajolla")
    # Setup subplots with two panels
    with fig.subplot(
        nrows=1, ncols=2, figsize=("13.5c", "4c"), title="Linear distribution"
    ):
        # Plot the grid with a linear distribution in the first panel
        with fig.set_panel(panel=0):
            fig.grdimage(grid=linear, projection="M?", frame="WSne", cmap=True)
        # Plot a histogram showing the linear z-value distribution
        with fig.set_panel(panel=1):
            fig.histogram(
                data=linear_dist,
                projection="X?",
                region=[-1, divisions, 0, 40],
                series=[0, divisions, 1],
                frame=["wnSE", "xaf+lRelative elevation", "yaf+lPercent frequency"],
                cmap=True,
                histtype=1,
                pen="1p,black",
                center=True,
            )
            fig.colorbar(position="JMR+o1.5c/0c+w3c/0.3c", frame=True)
    fig.show()





.. image-sg:: /tutorials/advanced/images/sphx_glr_grid_equalization_002.png
   :alt: grid equalization
   :srcset: /tutorials/advanced/images/sphx_glr_grid_equalization_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 133-140

Transform grid based on a normal distribution
---------------------------------------------

The ``gaussian`` parameter of :meth:`pygmt.grdhisteq.equalize_grid` can be
used to transform the z-values relative to their position in a normal
distribution rather than a linear distribution. In this case, the output
data are continuous rather than discrete.

.. GENERATED FROM PYTHON SOURCE LINES 140-145

.. code-block:: Python


    normal = pygmt.grdhisteq.equalize_grid(grid=grid, gaussian=True)
    normal_dist = pygmt.grd2xyz(grid=normal, output_type="pandas")["z"]









.. GENERATED FROM PYTHON SOURCE LINES 146-151

Plot the normally distributed data
----------------------------------

Here we create a map showing the grid that has been transformed to have
a normal distribution and a histogram of the data values.

.. GENERATED FROM PYTHON SOURCE LINES 151-181

.. code-block:: Python


    # Create an instance of the Figure class
    fig = pygmt.Figure()
    # Define figure configuration
    pygmt.config(FORMAT_GEO_MAP="ddd.x", MAP_FRAME_TYPE="plain")
    # Define the colormap for the figure
    pygmt.makecpt(series=[-4.5, 4.5], cmap="vik")
    # Setup subplots with two panels
    with fig.subplot(
        nrows=1, ncols=2, figsize=("13.5c", "4c"), title="Normal distribution"
    ):
        # Plot the grid with a normal distribution in the first panel
        with fig.set_panel(panel=0):
            fig.grdimage(grid=normal, projection="M?", frame="WSne", cmap=True)
        # Plot a histogram showing the normal z-value distribution
        with fig.set_panel(panel=1):
            fig.histogram(
                data=normal_dist,
                projection="X?",
                region=[-4.5, 4.5, 0, 20],
                series=[-4.5, 4.5, 0.2],
                frame=["wnSE", "xaf+lRelative elevation", "yaf+lPercent frequency"],
                cmap=True,
                histtype=1,
                pen="1p,black",
            )
            fig.colorbar(position="JMR+o1.5c/0c+w3c/0.3c", frame=True)
    fig.show()





.. image-sg:: /tutorials/advanced/images/sphx_glr_grid_equalization_003.png
   :alt: grid equalization
   :srcset: /tutorials/advanced/images/sphx_glr_grid_equalization_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 182-190

Equalize grid based on a quadratic distribution
-----------------------------------------------

The ``quadratic`` parameter of :meth:`pygmt.grdhisteq.equalize_grid` can be
used to transform the z-values relative to their position in a quadratic
distribution rather than a linear distribution. Here, we equalize the grid
into nine divisions based on a quadratic distribution and produce a
:class:`pandas.Series` with the z-values for the new grid.

.. GENERATED FROM PYTHON SOURCE LINES 190-197

.. code-block:: Python


    quadratic = pygmt.grdhisteq.equalize_grid(
        grid=grid, quadratic=True, divisions=divisions
    )
    quadratic_dist = pygmt.grd2xyz(grid=quadratic, output_type="pandas")["z"]









.. GENERATED FROM PYTHON SOURCE LINES 198-205

Calculate the bins used for data transformation
-----------------------------------------------

We can also use the ``quadratic`` parameter of
:meth:`pygmt.grdhisteq.compute_bins` to report the bins used for dividing
the grid into 9 divisions based on their position in a quadratic
distribution.

.. GENERATED FROM PYTHON SOURCE LINES 205-209

.. code-block:: Python


    pygmt.grdhisteq.compute_bins(grid=grid, divisions=divisions, quadratic=True)







.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>start</th>
          <th>stop</th>
        </tr>
        <tr>
          <th>bin_id</th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>508.0</td>
          <td>1155.0</td>
        </tr>
        <tr>
          <th>1</th>
          <td>1155.0</td>
          <td>1375.0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>1375.0</td>
          <td>1605.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>1605.0</td>
          <td>1821.0</td>
        </tr>
        <tr>
          <th>4</th>
          <td>1821.0</td>
          <td>1972.0</td>
        </tr>
        <tr>
          <th>5</th>
          <td>1972.0</td>
          <td>2131.0</td>
        </tr>
        <tr>
          <th>6</th>
          <td>2131.0</td>
          <td>2245.0</td>
        </tr>
        <tr>
          <th>7</th>
          <td>2245.0</td>
          <td>2391.0</td>
        </tr>
        <tr>
          <th>8</th>
          <td>2391.0</td>
          <td>3533.0</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 210-215

Plot the quadratic distribution of data
---------------------------------------

Here we create a map showing the grid that has been transformed to have
a quadratic distribution and a histogram of the data values.

.. GENERATED FROM PYTHON SOURCE LINES 215-245

.. code-block:: Python


    # Create an instance of the Figure class
    fig = pygmt.Figure()
    # Define figure configuration
    pygmt.config(FORMAT_GEO_MAP="ddd.x", MAP_FRAME_TYPE="plain")
    # Define the colormap for the figure
    pygmt.makecpt(series=[0, divisions, 1], cmap="lajolla")
    # Setup subplots with two panels
    with fig.subplot(
        nrows=1, ncols=2, figsize=("13.5c", "4c"), title="Quadratic distribution"
    ):
        # Plot the grid with a quadratic distribution in the first panel
        with fig.set_panel(panel=0):
            fig.grdimage(grid=quadratic, projection="M?", frame="WSne", cmap=True)
        # Plot a histogram showing the quadratic z-value distribution
        with fig.set_panel(panel=1):
            fig.histogram(
                data=quadratic_dist,
                projection="X?",
                region=[-1, divisions, 0, 40],
                series=[0, divisions, 1],
                frame=["wnSE", "xaf+lRelative elevation", "yaf+lPercent frequency"],
                cmap=True,
                histtype=1,
                pen="1p,black",
                center=True,
            )
            fig.colorbar(position="JMR+o1.5c/0c+w3c/0.3c", frame=True)
    fig.show()




.. image-sg:: /tutorials/advanced/images/sphx_glr_grid_equalization_004.png
   :alt: grid equalization
   :srcset: /tutorials/advanced/images/sphx_glr_grid_equalization_004.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.243 seconds)


.. _sphx_glr_download_tutorials_advanced_grid_equalization.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: grid_equalization.ipynb <grid_equalization.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: grid_equalization.py <grid_equalization.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: grid_equalization.zip <grid_equalization.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
